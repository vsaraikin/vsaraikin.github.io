<title>Message Queue</title>
<meta name="description" content="message queues">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="style/github-markdown.css">
<link rel="stylesheet" href="../style/style.css">
<article class="markdown-body">
<h1>Message Queue</h1>
<h2>Message Queues &amp; Message Brokers</h2>
<p>Брокеры сообщений используют очереди сообщений, чтобы передавать информацию. То есть MQ – это струтура данных, которая хранит что-то, а брокер – это софтина, которая управляет этим.</p>
<h3>Очереди</h3>
<p>Очередь — структура данных с дисциплиной доступа к элементам «первый пришёл — первый вышел». Добавление элемента возможно лишь в конец очереди, выборка — только из начала очереди, при этом выбранный элемент из очереди удаляется.</p>
<h3>Брокеры сообщений</h3>
<p>Брокер сообщений представляет собой тип построения архитектуры, при котором элементы системы «общаются» друг с другом с помощью посредника. Благодаря его работе происходит <em><strong>снятие нагрузки с веб-сервисов</strong></em>, так как им не приходится заниматься пересылкой сообщений: всю сопутствующую этому процессу работу он берёт на себя.</p>
<table>
<thead>
<tr>
<th>Преимущества</th>
<th>Недостатки</th>
</tr>
</thead>
<tbody>
<tr>
<td>Асинхронная коммуникация</td>
<td>Нужно управление по мониторингу</td>
</tr>
<tr>
<td>Отказоустойчивость (fault tolerance)</td>
<td>Дополнительная задержка</td>
</tr>
<tr>
<td>Гарантии доставки (обеспечивает различные уровни гарантий доставки, включая &quot;хотя бы один раз&quot; и &quot;ровно один раз&quot;)</td>
<td>Зависимость от работы брокера</td>
</tr>
<tr>
<td>Гибкость в маршрутизации  (можно динамически изменять пути сообщений и фильтровать сообщения на основе содержимого или заголовков)</td>
<td>Дополнительные требования к ресурсам</td>
</tr>
<tr>
<td>Масштабируемость</td>
<td>Дополнительные требования по безопасности</td>
</tr>
</tbody>
</table>
<h3>Когда брокеры сообщений могут быть полезны</h3>
<ul>
<li>Действия с задержкой, которые не требуют результата сейчас.</li>
<li>Координация микросервисов.</li>
</ul>
<h3>Гарантии доставки</h3>
<ul>
<li>At-most-once delivery – сообщение не может быть доставлено больше одного раза. При этом сообщение может быть потеряно.</li>
<li>At-least-once delivery – сообщение никогда не будет потеряно. При этом сообщение может быть доставлено более одного раза.</li>
<li>Exactly-once delivery (“строго однократная доставка”). Святой грааль систем сообщений. Все сообщения доставляются строго единожды.</li>
</ul>
<h2>Kafka</h2>
<h3>Сущности</h3>
<p><strong>ZooKeeper</strong> — инструмент-координатор, действует как общая служба конфигурации в системе. Работает как база для хранения метаданных о состоянии узлов кластера и расположении сообщений.</p>
<p><strong>Kafka Controller</strong> — среди брокеров Zookeeper выбирает одного, который будет обеспечивать консистентность данных.</p>
<ul>
<li><strong>Topics</strong> – это “папка” для сообщений. В топик складывается стрим данных, единая очередь из входящих сообщений.</li>
<li><strong>Partitions</strong> – это упорядоченная последовательность сообщений. Для ускорения чтения и записи топики делятся на партиции. Происходит параллелизация данных. Это конфигурируемый параметр, сообщения могут отправлять несколько продюсеров и принимать несколько консьюмеров.</li>
<li><strong>Producers</strong></li>
<li><strong>Consumers</strong></li>
<li><strong>Clusters</strong> – один или несколько хостов-брокеров, на которых размещены топики и соответствующие топикам разделы.</li>
<li><strong>Brokers</strong></li>
</ul>
<p>Продьюсеры отправляют записи в кластеры, которые хранят записи и далее отправляют их консьюмерам. Каждая нода в класетере – это брокер, который хранит данные переданные продьюсером до тех пор, пока их не вычитает консьюмер.</p>
<p><img src="kafka-core.png" alt="kafka-core" /></p>
<h3>Records</h3>
<p>Записи – это самый простой юнит в Kafka, event какой-то по факту. Содержит:</p>
<ul>
<li>Ключ</li>
<li>Значение</li>
<li>Заголовки</li>
<li>Номер партиции</li>
<li>Офсет</li>
<li>Timestamp</li>
</ul>
<h3>Offset</h3>
<p>Офсет – это позиция (индекс) сообщения в определенном topic и partition, который указывает на то, какие сообщения были уже прочитаны consumer.</p>
<p>Если консьюмер падает в процессе получения данных, то, когда он запустится вновь и ему нужно будет вернутся к чтению этого сообщения, он воспользуется офсетом и продолжит с нужного места.</p>
<h4>Committing offsets</h4>
<p>Это процесс, посредством которого consumers в Kafka сообщают брокеру о том, какие сообщения они уже успешно обработали.</p>
<p>В Kafka offsets могут быть автоматически зафиксированы (auto-commit) или управляемы вручную (manual commit).</p>
<ul>
<li><strong>Автоматическая фиксация offsets</strong>: Kafka может быть настроен на автоматическую фиксацию offsets через определенные интервалы времени. Хотя это упрощает управление, оно может привести к потере или повторной обработке сообщений при непредвиденных перезапусках потребителей.</li>
<li><strong>Ручная фиксация offsets</strong>: Дает разработчикам полный контроль над тем, когда и какие offsets должны быть зафиксированы. Это позволяет более точно управлять обработкой сообщений, особенно в распределенных системах, где требуется высокая надежность и гарантии обработки сообщений.</li>
</ul>
<h4>Зачем нужно commit offsets?</h4>
<ul>
<li><strong>Для обеспечения доставки &quot;точно один раз&quot; (exactly once delivery)</strong>: Путем фиксации offsets потребители могут точно отслеживать, до какого момента в потоке данных они продвинулись. Это позволяет избежать повторной обработки уже прочитанных сообщений после перезапуска или сбоя потребителя.</li>
<li><strong>Для гарантии упорядоченной обработки сообщений</strong>: В системах, где порядок сообщений критичен, фиксация offsets обеспечивает возможность следовать этому порядку, даже если произошел сбой или необходимо перераспределить обработку между разными потребителями.</li>
</ul>
<h3>Partition</h3>
<p>Партиция — это упорядоченная и неизменяемая последовательность сообщений, которая хранит данные внутри топика.</p>
<h3>Consumer group</h3>
<p>Консьюмер группа – это набор консьюмеров, объединенных одним ID, где вся группа слушает один топик и только один консьюмер вычитывает одно сообщение.</p>
<p><img src="kafka-2-partitions-2-consumers.png" alt="kafka-2-partitions-2-consumers" /></p>
<p>Если окажется, что нужно поставить третьего консьюмера, то надо ставить и третью партицию.</p>
<p>Или же, если нужно потреблять ивент другим consumer, то нужно создать отдельную consumer group.</p>
<p><img src="kafka-partitions-2-consumer-3.webp" alt="kafka-partitions-2-consumer-3" /></p>
<p><em>Reference:</em> <a href="https://codingharbour.com/apache-kafka/what-is-a-consumer-group-in-kafka/">What is a consumer group in Kafka? - Coding Harbour</a></p>
<h3>Преимущества Kafka</h3>
<h4>Горизонтальное масштабирование</h4>
<p>Множество объединенных серверов гарантируют высокую доступность данных — выход из строя одного из узлов не нарушает целостность. Кластер состоит из обычных машин, а не суперкомпьютеров, их можно менять и дополнять. Система автоматически перебалансируется.</p>
<p>Чтобы события не потерялись, существуют механизмы репликации. Данные записываются на несколько машин, если что-то случается с сервером, он переключается на резервный. Кластер в режиме реального времени определяет, где находятся данные, и продолжает их использовать.</p>
<h4>Принцип first in — first out</h4>
<p>Принцип FIFO действует на консьюмеров. Чтение происходит в том же порядке, в котором пришла информация.</p>
<h3>Можно ли вычитывать сообщения разными консьюмерами из одной партиции?</h3>
<p>Обычно рекомендуется иметь не более одного консьюмера из одной и той же группы консьюмеров, читающего из одной партиции. Это обеспечивает упорядоченное чтение в рамках партиции.</p>
<p>Технически возможно иметь несколько консьюмеров из разных групп консьюмеров, читающих из одной и той же партиции. Однако это может привести к дублированию сообщений для разных групп консьюмеров.</p>
<h3>Что если отправитель и получатель пишут много сообщений, попали в одну партицию?</h3>
<p>Отправить их в отдельную партицию</p>
<h3>Можно ли потерять сообщение, когда его отправили в очередь?</h3>
<h3>Exactly-Once</h3>
<h3>Idempotency Keys</h3>
<h2>RabbitMQ</h2>
<ul>
<li>producers</li>
<li>exchanges (how messages are routed—provide a great deal of flexibility)</li>
<li>queues</li>
<li>consumers</li>
</ul>
<p>A producer pushes messages to an exchange, which then routes messages to queues (or other exchanges). A consumer then continues to read messages from the queue, often up to a predetermined limit of messages.</p>
<p>Producers add data to the tail of the queue; consumers receive data from the head of the queue. The queues are “first in, first out” with RabbitMQ: the first message in the queue is consumed first.</p>
<h3>Преимущества RabbitMQ</h3>
<h2>RabbitMQ vs Kafka</h2>
<h4>Сценарии использования</h4>
<ul>
<li><strong>Kafka</strong> подходит для сценариев, где данные передаются между компонентами в виде непрерывных потоков событий, а также для аналитики в реальном времени (больше похожа на шину, чем на очередь).</li>
<li><strong>RabbitMQ</strong> хорошо подходит для сценариев, где необходимо гарантировать доставку сообщений в определенном порядке и обеспечить независимость компонентов друг от друга.</li>
</ul>
<h4>Сохранение сообщений</h4>
<ul>
<li><strong>Kafka</strong> сохраняет сообщения на определенное время (или скорее на любое время в объеме, на который хватит размера хранилища). Это позволяет обрабатывать и анализировать данные в любой момент времени, даже после их передачи.</li>
<li><strong>RabbitMQ</strong> хранит сообщения в очередях до тех пор, пока получатель их не обработает и подтвердит. После сообщение удаляется.</li>
</ul>
<h4>Порядок сообщений</h4>
<ul>
<li>Kafka: не гарантирует</li>
<li>RabbitMQ: гарантирует</li>
</ul>
<h4>Модели доставки</h4>
<ul>
<li>Kafka добавляет сообщение в журнал, и консьюмер сам забирает информацию из топика</li>
<li>RabbitMQ самостоятельно отправляет сообщения получателям — помещает событие в очередь и отслеживает его статус.</li>
</ul>
<h3>Гарантии доставки в Kafka vs RabbitMQ</h3>
<h4>Гарантии доставки в RabbitMQ</h4>
<ul>
<li>надежностью сообщений — они не пропадут, пока хранятся на RabbitMQ;</li>
<li>уведомлениями о сообщениях — RabbitMQ обменивается сигналами с отправителями и получателями.</li>
</ul>
<h4>Гарантии доставки в Kafka</h4>
<ul>
<li>долговечность сообщений — сообщения, сохранённые в сегменте, не теряются;</li>
<li>уведомлениями о сообщениях — обмен сигналами между Kafka (и, возможно, хранилищем Apache Zookeeper) с одной стороны и источником/получателем — с другой.</li>
</ul>
<p><em>References:</em></p>
<ul>
<li><a href="https://habr.com/ru/company/itsumma/blog/437446/">Apache Kafka и RabbitMQ: семантика и гарантия доставки сообщений</a></li>
<li><a href="https://habr.com/ru/company/itsumma/blog/416629/">RabbitMQ против Kafka: два разных подхода к обмену сообщениями</a></li>
<li><a href="https://medium.com/@vozerov/kafka-vs-rabbitmq-38e221cf511b">Kafka VS RabbitMQ</a></li>
</ul>
<hr />
<h2>Паттерны</h2>
<h3>1. Request-Reply (Запрос-Ответ)</h3>
<ul>
<li><strong>Описание</strong>: Этот паттерн представляет собой двухстороннюю коммуникацию, где один компонент (запрашивающий) отправляет запрос, а другой (отвечающий) получает запрос и отправляет ответ обратно.</li>
<li><strong>Применение</strong>: Широко используется в синхронных операциях, где требуется немедленный ответ, например, в веб-сервисах или при удаленном вызове процедур (RPC).</li>
<li><strong>Технология</strong>: HTTP/HTTPS, gRPC, Apache Thrift</li>
</ul>
<h3>2. Publish-Subscribe (Публикация-Подписка)</h3>
<ul>
<li><strong>Описание</strong>: В этом паттерне издатель (publisher) отправляет сообщения без указания конкретного получателя, а подписчики (subscribers) получают сообщения на основе своих подписок.</li>
<li><strong>Применение</strong>: Используется для рассылки уведомлений, широковещательной коммуникации и в сценариях, где одно сообщение должно быть доставлено многим получателям.</li>
<li><strong>Технология</strong>: Apache Kafka, RabbitMQ, MQTT</li>
</ul>
<h3>3. Synchronous (Синхронный)</h3>
<ul>
<li><strong>Описание</strong>: Синхронная передача данных требует, чтобы отправитель ожидал ответа после отправки каждого сообщения.</li>
<li><strong>Применение</strong>: Подходит для сценариев, где важна тесная связь между отправкой запроса и получением ответа, например, в запросах к базе данных или при обработке транзакций.</li>
<li><strong>Технология</strong>: Традиционные веб-сервисы, SQL базы данных</li>
</ul>
<h3>4. Asynchronous (Асинхронный)</h3>
<ul>
<li><strong>Описание</strong>: В асинхронном обмене сообщениями отправитель не ожидает немедленного ответа и может продолжать свою работу независимо от того, обработано ли сообщение получателем.</li>
<li><strong>Применение</strong>: Асинхронные паттерны идеально подходят для фоновой обработки, длительных задач, обмена сообщениями в системах с высокой пропускной способностью и низкой задержкой.</li>
<li><strong>Технология</strong>: AMQP, Amazon SQS, Node.js</li>
</ul>
<h3>5. Competing Consumers (Соревнующиеся Потребители)</h3>
<ul>
<li><strong>Описание</strong>: В этом паттерне несколько потребителей (consumers) прослушивают одну и ту же очередь сообщений, и когда сообщение поступает, один из потребителей выбирается для его обработки.</li>
<li><strong>Применение</strong>: Эффективен для масштабирования обработки сообщений, распределяя нагрузку между несколькими экземплярами потребителей.</li>
<li><strong>Технология</strong>: RabbitMQ, Apache Kafka</li>
</ul>
<h3>6. Work Queues (Очереди Работы)</h3>
<ul>
<li><strong>Описание</strong>: Распределение задач между несколькими рабочими процессами, где каждая задача обрабатывается один раз одним рабочим процессом.</li>
<li><strong>Применение</strong>: Подходит для распределённой обработки задач, когда задачи могут быть независимо выполнены различными рабочими процессами.</li>
<li><strong>Технология</strong>: Celery (с использованием RabbitMQ или Redis)</li>
</ul>
<h3>7. Message Routing (Маршрутизация Сообщений)</h3>
<ul>
<li><strong>Описание</strong>: Определение правил или критериев для маршрутизации сообщений по различным путям или в разные очереди.</li>
<li><strong>Применение</strong>: Используется для управления потоком данных в системе, например, для фильтрации, агрегации или преобразования сообщений.</li>
<li><strong>Технология</strong>: Apache Camel, Mule ESB</li>
</ul>
<h3>8. Scatter-Gather (Разброс-Сбор)</h3>
<ul>
<li><strong>Описание</strong>: Отправка запроса нескольким получателям и последующий сбор и агрегация ответов.</li>
<li><strong>Применение</strong>: Подходит для ситуаций, когда необходимо выполнить параллельные запросы и собрать результаты, например, для агрегации данных из нескольких источников.</li>
<li><strong>Технология</strong>: Apache Kafka, Apache Spark</li>
</ul>
<h3>9. Fan-out/Fan-in (Разветвление/Схождение)</h3>
<ul>
<li><strong>Описание</strong>: Распространение сообщения на несколько получателей (fan-out) и последующее схождение результатов обработки (fan-in).</li>
<li><strong>Применение</strong>: Эффективен для параллельной обработки и последующей агрегации результатов.</li>
<li><strong>Технология</strong>: AWS Lambda, Google Cloud Functions</li>
</ul>
<p><a href="https://learn.microsoft.com/en-us/azure/architecture/patterns/">Cloud design patterns - Azure Architecture Center | Microsoft Learn</a></p>

</article>
