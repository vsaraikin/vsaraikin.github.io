# Message Queue 

## Message Queues & Message Brokers

Брокеры сообщений используют очереди сообщений, чтобы передавать информацию. То есть MQ – это струтура данных, которая хранит что-то, а брокер – это софтина, которая управляет этим.

### Очереди

Очередь — структура данных с дисциплиной доступа к элементам «первый пришёл — первый вышел». Добавление элемента возможно лишь в конец очереди, выборка — только из начала очереди, при этом выбранный элемент из очереди удаляется.

### Брокеры сообщений

Брокер сообщений представляет собой тип построения архитектуры, при котором элементы системы «общаются» друг с другом с помощью посредника. Благодаря его работе происходит ***снятие нагрузки с веб-сервисов***, так как им не приходится заниматься пересылкой сообщений: всю сопутствующую этому процессу работу он берёт на себя.

| Преимущества | Недостатки |
| ---- | ---- |
| Асинхронная коммуникация | Нужно управление по мониторингу |
| Отказоустойчивость (fault tolerance) | Дополнительная задержка |
| Гарантии доставки (обеспечивает различные уровни гарантий доставки, включая "хотя бы один раз" и "ровно один раз") | Зависимость от работы брокера |
| Гибкость в маршрутизации  (можно динамически изменять пути сообщений и фильтровать сообщения на основе содержимого или заголовков) | Дополнительные требования к ресурсам |
| Масштабируемость | Дополнительные требования по безопасности |

### Когда брокеры сообщений могут быть полезны

- Действия с задержкой, которые не требуют результата сейчас.
- Координация микросервисов.

### Гарантии доставки

- At-most-once delivery – сообщение не может быть доставлено больше одного раза. При этом сообщение может быть потеряно.
- At-least-once delivery – сообщение никогда не будет потеряно. При этом сообщение может быть доставлено более одного раза.
- Exactly-once delivery (“строго однократная доставка”). Святой грааль систем сообщений. Все сообщения доставляются строго единожды.

## Kafka

### Сущности

**ZooKeeper** — инструмент-координатор, действует как общая служба конфигурации в системе. Работает как база для хранения метаданных о состоянии узлов кластера и расположении сообщений.

**Kafka Controller** — среди брокеров Zookeeper выбирает одного, который будет обеспечивать консистентность данных.

- **Topics** – это “папка” для сообщений. В топик складывается стрим данных, единая очередь из входящих сообщений.
- **Partitions** – это упорядоченная последовательность сообщений. Для ускорения чтения и записи топики делятся на партиции. Происходит параллелизация данных. Это конфигурируемый параметр, сообщения могут отправлять несколько продюсеров и принимать несколько консьюмеров.
- **Producers**
- **Consumers**
- **Clusters** – один или несколько хостов-брокеров, на которых размещены топики и соответствующие топикам разделы.
- **Brokers**

Продьюсеры отправляют записи в кластеры, которые хранят записи и далее отправляют их консьюмерам. Каждая нода в класетере – это брокер, который хранит данные переданные продьюсером до тех пор, пока их не вычитает консьюмер.

![kafka-core](kafka-core.png)

### Records

Записи – это самый простой юнит в Kafka, event какой-то по факту. Содержит:

- Ключ
- Значение
- Заголовки
- Номер партиции
- Офсет
- Timestamp

### Offset

Офсет – это позиция (индекс) сообщения в определенном topic и partition, который указывает на то, какие сообщения были уже прочитаны consumer.

Если консьюмер падает в процессе получения данных, то, когда он запустится вновь и ему нужно будет вернутся к чтению этого сообщения, он воспользуется офсетом и продолжит с нужного места.

#### Committing offsets

Это процесс, посредством которого consumers в Kafka сообщают брокеру о том, какие сообщения они уже успешно обработали.

В Kafka offsets могут быть автоматически зафиксированы (auto-commit) или управляемы вручную (manual commit).

- **Автоматическая фиксация offsets**: Kafka может быть настроен на автоматическую фиксацию offsets через определенные интервалы времени. Хотя это упрощает управление, оно может привести к потере или повторной обработке сообщений при непредвиденных перезапусках потребителей.
- **Ручная фиксация offsets**: Дает разработчикам полный контроль над тем, когда и какие offsets должны быть зафиксированы. Это позволяет более точно управлять обработкой сообщений, особенно в распределенных системах, где требуется высокая надежность и гарантии обработки сообщений.

#### Зачем нужно commit offsets?

- **Для обеспечения доставки "точно один раз" (exactly once delivery)**: Путем фиксации offsets потребители могут точно отслеживать, до какого момента в потоке данных они продвинулись. Это позволяет избежать повторной обработки уже прочитанных сообщений после перезапуска или сбоя потребителя.
- **Для гарантии упорядоченной обработки сообщений**: В системах, где порядок сообщений критичен, фиксация offsets обеспечивает возможность следовать этому порядку, даже если произошел сбой или необходимо перераспределить обработку между разными потребителями.

### Partition

Партиция — это упорядоченная и неизменяемая последовательность сообщений, которая хранит данные внутри топика.

### Consumer group

Консьюмер группа – это набор консьюмеров, объединенных одним ID, где вся группа слушает один топик и только один консьюмер вычитывает одно сообщение.

![kafka-2-partitions-2-consumers](kafka-2-partitions-2-consumers.png)

Если окажется, что нужно поставить третьего консьюмера, то надо ставить и третью партицию.

Или же, если нужно потреблять ивент другим consumer, то нужно создать отдельную consumer group.

![kafka-partitions-2-consumer-3](kafka-partitions-2-consumer-3.webp)

*Reference:* [What is a consumer group in Kafka? - Coding Harbour](https://codingharbour.com/apache-kafka/what-is-a-consumer-group-in-kafka/)

### Преимущества Kafka

#### Горизонтальное масштабирование

Множество объединенных серверов гарантируют высокую доступность данных — выход из строя одного из узлов не нарушает целостность. Кластер состоит из обычных машин, а не суперкомпьютеров, их можно менять и дополнять. Система автоматически перебалансируется. 

Чтобы события не потерялись, существуют механизмы репликации. Данные записываются на несколько машин, если что-то случается с сервером, он переключается на резервный. Кластер в режиме реального времени определяет, где находятся данные, и продолжает их использовать.

#### Принцип first in — first out

Принцип FIFO действует на консьюмеров. Чтение происходит в том же порядке, в котором пришла информация.

### Можно ли вычитывать сообщения разными консьюмерами из одной партиции?

Обычно рекомендуется иметь не более одного консьюмера из одной и той же группы консьюмеров, читающего из одной партиции. Это обеспечивает упорядоченное чтение в рамках партиции.

Технически возможно иметь несколько консьюмеров из разных групп консьюмеров, читающих из одной и той же партиции. Однако это может привести к дублированию сообщений для разных групп консьюмеров.

### Что если отправитель и получатель пишут много сообщений, попали в одну партицию?

Отправить их в отдельную партицию

### Можно ли потерять сообщение, когда его отправили в очередь?

### Exactly-Once

### Idempotency Keys

## RabbitMQ

- producers
- exchanges (how messages are routed—provide a great deal of flexibility)
- queues
- consumers

A producer pushes messages to an exchange, which then routes messages to queues (or other exchanges). A consumer then continues to read messages from the queue, often up to a predetermined limit of messages.

Producers add data to the tail of the queue; consumers receive data from the head of the queue. The queues are “first in, first out” with RabbitMQ: the first message in the queue is consumed first.

### Преимущества RabbitMQ


## RabbitMQ vs Kafka

#### Сценарии использования

- **Kafka** подходит для сценариев, где данные передаются между компонентами в виде непрерывных потоков событий, а также для аналитики в реальном времени (больше похожа на шину, чем на очередь).
- **RabbitMQ** хорошо подходит для сценариев, где необходимо гарантировать доставку сообщений в определенном порядке и обеспечить независимость компонентов друг от друга.

#### Сохранение сообщений

- **Kafka** сохраняет сообщения на определенное время (или скорее на любое время в объеме, на который хватит размера хранилища). Это позволяет обрабатывать и анализировать данные в любой момент времени, даже после их передачи.
- **RabbitMQ** хранит сообщения в очередях до тех пор, пока получатель их не обработает и подтвердит. После сообщение удаляется.

#### Порядок сообщений

- Kafka: не гарантирует
- RabbitMQ: гарантирует

#### Модели доставки

- Kafka добавляет сообщение в журнал, и консьюмер сам забирает информацию из топика
- RabbitMQ самостоятельно отправляет сообщения получателям — помещает событие в очередь и отслеживает его статус.

### Гарантии доставки в Kafka vs RabbitMQ

#### Гарантии доставки в RabbitMQ

- надежностью сообщений — они не пропадут, пока хранятся на RabbitMQ;
- уведомлениями о сообщениях — RabbitMQ обменивается сигналами с отправителями и получателями.

#### Гарантии доставки в Kafka

- долговечность сообщений — сообщения, сохранённые в сегменте, не теряются;
- уведомлениями о сообщениях — обмен сигналами между Kafka (и, возможно, хранилищем Apache Zookeeper) с одной стороны и источником/получателем — с другой.

*References:*

- [Apache Kafka и RabbitMQ: семантика и гарантия доставки сообщений](https://habr.com/ru/company/itsumma/blog/437446/)
- [RabbitMQ против Kafka: два разных подхода к обмену сообщениями](https://habr.com/ru/company/itsumma/blog/416629/)
- [Kafka VS RabbitMQ](https://medium.com/@vozerov/kafka-vs-rabbitmq-38e221cf511b)

---
## Паттерны

### 1. Request-Reply (Запрос-Ответ)

- **Описание**: Этот паттерн представляет собой двухстороннюю коммуникацию, где один компонент (запрашивающий) отправляет запрос, а другой (отвечающий) получает запрос и отправляет ответ обратно.
- **Применение**: Широко используется в синхронных операциях, где требуется немедленный ответ, например, в веб-сервисах или при удаленном вызове процедур (RPC).
- **Технология**: HTTP/HTTPS, gRPC, Apache Thrift

### 2. Publish-Subscribe (Публикация-Подписка)

- **Описание**: В этом паттерне издатель (publisher) отправляет сообщения без указания конкретного получателя, а подписчики (subscribers) получают сообщения на основе своих подписок.
- **Применение**: Используется для рассылки уведомлений, широковещательной коммуникации и в сценариях, где одно сообщение должно быть доставлено многим получателям.
- **Технология**: Apache Kafka, RabbitMQ, MQTT

### 3. Synchronous (Синхронный)

- **Описание**: Синхронная передача данных требует, чтобы отправитель ожидал ответа после отправки каждого сообщения.
- **Применение**: Подходит для сценариев, где важна тесная связь между отправкой запроса и получением ответа, например, в запросах к базе данных или при обработке транзакций.
- **Технология**: Традиционные веб-сервисы, SQL базы данных

### 4. Asynchronous (Асинхронный)

- **Описание**: В асинхронном обмене сообщениями отправитель не ожидает немедленного ответа и может продолжать свою работу независимо от того, обработано ли сообщение получателем.
- **Применение**: Асинхронные паттерны идеально подходят для фоновой обработки, длительных задач, обмена сообщениями в системах с высокой пропускной способностью и низкой задержкой.
- **Технология**: AMQP, Amazon SQS, Node.js

### 5. Competing Consumers (Соревнующиеся Потребители)

- **Описание**: В этом паттерне несколько потребителей (consumers) прослушивают одну и ту же очередь сообщений, и когда сообщение поступает, один из потребителей выбирается для его обработки.
- **Применение**: Эффективен для масштабирования обработки сообщений, распределяя нагрузку между несколькими экземплярами потребителей.
- **Технология**: RabbitMQ, Apache Kafka
### 6. Work Queues (Очереди Работы)

- **Описание**: Распределение задач между несколькими рабочими процессами, где каждая задача обрабатывается один раз одним рабочим процессом.
- **Применение**: Подходит для распределённой обработки задач, когда задачи могут быть независимо выполнены различными рабочими процессами.
- **Технология**: Celery (с использованием RabbitMQ или Redis)

### 7. Message Routing (Маршрутизация Сообщений)

- **Описание**: Определение правил или критериев для маршрутизации сообщений по различным путям или в разные очереди.
- **Применение**: Используется для управления потоком данных в системе, например, для фильтрации, агрегации или преобразования сообщений.
- **Технология**: Apache Camel, Mule ESB

### 8. Scatter-Gather (Разброс-Сбор)

- **Описание**: Отправка запроса нескольким получателям и последующий сбор и агрегация ответов.
- **Применение**: Подходит для ситуаций, когда необходимо выполнить параллельные запросы и собрать результаты, например, для агрегации данных из нескольких источников.
- **Технология**: Apache Kafka, Apache Spark

### 9. Fan-out/Fan-in (Разветвление/Схождение)

- **Описание**: Распространение сообщения на несколько получателей (fan-out) и последующее схождение результатов обработки (fan-in).
- **Применение**: Эффективен для параллельной обработки и последующей агрегации результатов.
- **Технология**: AWS Lambda, Google Cloud Functions

[Cloud design patterns - Azure Architecture Center | Microsoft Learn](https://learn.microsoft.com/en-us/azure/architecture/patterns/)